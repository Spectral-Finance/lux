# Telegram Integration Guide

```elixir
Mix.install([
  {:lux, ">= 0.5.0"},
  {:kino, "~> 0.14.2"}
])

Application.ensure_all_started([:ex_unit])
```

## Overview

<a href="https://livebook.dev/run?url=https%3A%2F%2Fgithub.com%2FSpectral-Finance%2Flux%2Fblob%2Fmain%2Flux%2Fguides%2Ftelegram.livemd" style="display: none">
  <img src="https://livebook.dev/badge/v1/blue.svg" alt="Run in Livebook" />
</a>

Lux provides a comprehensive set of Lenses for interacting with the Telegram Bot API. These Lenses handle authentication, rate limiting, and error handling, making it easy to build Telegram bots and integrations.

This guide covers:

* Setting up a Telegram bot
* Sending and managing messages
* Working with media
* Rate limiting and error handling

## Setup

To use the Telegram Lenses, you need a Telegram Bot Token. You can get one by talking to [@BotFather](https://t.me/botfather) on Telegram.

```elixir
# Set your Telegram Bot Token
# You can also set this in your environment variables
telegram_bot_token = System.get_env("TELEGRAM_BOT_TOKEN") || "YOUR_BOT_TOKEN"
Application.put_env(:lux, :api_keys, [telegram_bot: telegram_bot_token])

# Set your chat ID for testing
# This could be your own chat with the bot or a test group
chat_id = System.get_env("TELEGRAM_TEST_CHAT_ID") || "YOUR_CHAT_ID"

# Create a frame for displaying results
frame = Kino.Frame.new() |> Kino.render()

Kino.nothing()
```

## Sending Messages

The `SendMessage` lens allows you to send text messages to Telegram chats.

```elixir
alias Lux.Lenses.Telegram.SendMessage

# Send a simple text message
{:ok, result} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "Hello from Lux! ðŸ‘‹"
})

Kino.Frame.append(frame, "Message sent with ID: #{result.message_id}")

# Send a message with Markdown formatting
{:ok, result} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "*Bold* and _italic_ text with [Lux](https://github.com/Spectral-Finance/lux)",
  parse_mode: "Markdown"
})

Kino.Frame.append(frame, "Formatted message sent with ID: #{result.message_id}")

Kino.nothing()
```

## Sending Photos

The `SendPhoto` lens allows you to send photos to Telegram chats.

```elixir
alias Lux.Lenses.Telegram.SendPhoto

# Send a photo by URL
{:ok, result} = SendPhoto.focus(%{
  chat_id: chat_id,
  photo: "https://picsum.photos/500/300",
  caption: "A random photo from Lorem Picsum"
})

Kino.Frame.append(frame, "Photo sent with ID: #{result.message_id}")

# Send a photo with Markdown formatting in caption
{:ok, result} = SendPhoto.focus(%{
  chat_id: chat_id,
  photo: "https://picsum.photos/500/300",
  caption: "*Beautiful* photo with _formatting_",
  parse_mode: "Markdown"
})

Kino.Frame.append(frame, "Photo with formatted caption sent with ID: #{result.message_id}")

Kino.nothing()
```

## Message Management

Lux provides several lenses for managing messages:

### Forwarding Messages

```elixir
alias Lux.Lenses.Telegram.ForwardMessage

# First, send a message to get a message_id
{:ok, original_message} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message will be forwarded"
})

# Now forward that message
{:ok, result} = ForwardMessage.focus(%{
  chat_id: chat_id,
  from_chat_id: chat_id,
  message_id: original_message.message_id
})

Kino.Frame.append(frame, "Message forwarded with ID: #{result.message_id}")

Kino.nothing()
```

### Copying Messages

Unlike forwarding, copied messages don't have a link to the original message.

```elixir
alias Lux.Lenses.Telegram.CopyMessage

# First, send a message to get a message_id
{:ok, original_message} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message will be copied"
})

# Now copy that message
{:ok, result} = CopyMessage.focus(%{
  chat_id: chat_id,
  from_chat_id: chat_id,
  message_id: original_message.message_id
})

Kino.Frame.append(frame, "Message copied with ID: #{result.message_id}")

# Copy with a new caption
{:ok, result} = CopyMessage.focus(%{
  chat_id: chat_id,
  from_chat_id: chat_id,
  message_id: original_message.message_id,
  caption: "This is a new caption for the copied message",
  parse_mode: "Markdown"
})

Kino.Frame.append(frame, "Message copied with new caption, ID: #{result.message_id}")

Kino.nothing()
```

### Editing Messages

You can edit the text of messages you've sent:

```elixir
alias Lux.Lenses.Telegram.EditMessageText

# First, send a message to get a message_id
{:ok, original_message} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message will be edited"
})

# Now edit that message
{:ok, result} = EditMessageText.focus(%{
  chat_id: chat_id,
  message_id: original_message.message_id,
  text: "This message has been edited! âœï¸"
})

Kino.Frame.append(frame, "Message edited with ID: #{result.message_id}")

# Edit with formatting
{:ok, result} = EditMessageText.focus(%{
  chat_id: chat_id,
  message_id: original_message.message_id,
  text: "*Bold* and _italic_ edited text",
  parse_mode: "Markdown"
})

Kino.Frame.append(frame, "Message edited with formatting, ID: #{result.message_id}")

Kino.nothing()
```

### Editing Captions

For media messages, you can edit the caption:

```elixir
alias Lux.Lenses.Telegram.EditMessageCaption

# First, send a photo with a caption
{:ok, original_message} = SendPhoto.focus(%{
  chat_id: chat_id,
  photo: "https://picsum.photos/500/300",
  caption: "Original caption"
})

# Now edit the caption
{:ok, result} = EditMessageCaption.focus(%{
  chat_id: chat_id,
  message_id: original_message.message_id,
  caption: "Updated caption! ðŸ“"
})

Kino.Frame.append(frame, "Caption edited for message ID: #{result.message_id}")

Kino.nothing()
```

### Deleting Messages

You can delete messages you've sent:

```elixir
alias Lux.Lenses.Telegram.DeleteMessage

# First, send a message to get a message_id
{:ok, original_message} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message will be deleted"
})

# Wait a moment to see the message
Process.sleep(2000)

# Now delete that message
{:ok, _result} = DeleteMessage.focus(%{
  chat_id: chat_id,
  message_id: original_message.message_id
})

Kino.Frame.append(frame, "Message deleted successfully")

Kino.nothing()
```

## Rate Limiting and Error Handling

The Telegram API has rate limits that restrict how many requests you can make in a given time period. Lux's Telegram Lenses automatically handle these rate limits and provide retry mechanisms for temporary errors.

### Rate Limits

The Telegram API has several types of rate limits:

* Global limit: 30 requests per second
* Chat-specific limit: 1 message per chat per second
* Group chat limit: 20 messages per minute per group

The `TelegramAPIHandler` module automatically applies these rate limits to all Telegram API requests.

### Error Handling with Retries

Temporary errors (like network issues or server overloads) are automatically retried with exponential backoff:

```elixir
alias Lux.Lenses.Telegram.TelegramAPIHandler

# Example of using the request_with_handling function directly
result = TelegramAPIHandler.request_with_handling(
  SendMessage,
  %{
    chat_id: chat_id,
    text: "Message with custom retry options"
  },
  [
    max_retries: 5,        # Maximum number of retry attempts
    initial_delay: 2000,   # Initial delay in milliseconds
    max_delay: 30000       # Maximum delay in milliseconds
  ]
)

case result do
  {:ok, response} ->
    Kino.Frame.append(frame, "Message sent with ID: #{response.message_id}")
  
  {:error, error} ->
    Kino.Frame.append(frame, "Error: #{inspect(error)}")
end

Kino.nothing()
```

## Advanced Usage

### Silent Messages

You can send messages without triggering a notification:

```elixir
{:ok, result} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message won't trigger a notification",
  disable_notification: true
})

Kino.Frame.append(frame, "Silent message sent with ID: #{result.message_id}")

Kino.nothing()
```

### Protected Content

You can protect the contents of messages from forwarding and saving:

```elixir
{:ok, result} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "This message is protected from forwarding and saving",
  protect_content: true
})

Kino.Frame.append(frame, "Protected message sent with ID: #{result.message_id}")

Kino.nothing()
```

### Disabling Web Page Previews

For messages with links, you can disable the automatic web page preview:

```elixir
{:ok, result} = SendMessage.focus(%{
  chat_id: chat_id,
  text: "Check out https://github.com/Spectral-Finance/lux (no preview)",
  disable_web_page_preview: true
})

Kino.Frame.append(frame, "Message with disabled preview sent with ID: #{result.message_id}")

Kino.nothing()
```

## Building a Simple Echo Bot

Let's put everything together to build a simple echo bot that responds to messages:

```elixir
defmodule EchoBot do
  alias Lux.Lenses.Telegram.SendMessage
  
  def process_update(%{"message" => message}) do
    chat_id = message["chat"]["id"]
    text = message["text"]
    
    if text do
      SendMessage.focus(%{
        chat_id: chat_id,
        text: "You said: #{text}",
        reply_to_message_id: message["message_id"]
      })
    end
  end
  
  def process_update(_), do: {:ok, :ignored}
end

# In a real application, you would set up a webhook or use getUpdates
# to receive messages from users. For this example, we'll simulate a message:

simulated_update = %{
  "message" => %{
    "message_id" => 123,
    "chat" => %{"id" => chat_id},
    "text" => "Hello, bot!",
    "from" => %{"id" => 456, "first_name" => "Test User"}
  }
}

EchoBot.process_update(simulated_update)

Kino.Frame.append(frame, "Echo bot processed the message")

Kino.nothing()
```

## Conclusion

The Telegram Lenses in Lux provide a powerful and easy-to-use interface for building Telegram bots and integrations. They handle all the complexities of working with the Telegram API, including authentication, rate limiting, and error handling.

For more information, check out the [Telegram Bot API documentation](https://core.telegram.org/bots/api) and the [Lux documentation](https://hexdocs.pm/lux). 